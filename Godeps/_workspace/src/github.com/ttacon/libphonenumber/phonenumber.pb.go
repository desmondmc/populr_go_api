// Code generated by protoc-gen-go.
// source: phonenumber.proto
// DO NOT EDIT!

package libphonenumber

import proto "github.com/golang/protobuf/proto"
import json "encoding/json"
import math "math"

// Reference proto, json, and math imports to suppress error if they are not otherwise used.
var _ = proto.Marshal
var _ = &json.SyntaxError{}
var _ = math.Inf

// The source from which the country_code is derived. This is not set in the general parsing method,
// but in the method that parses and keeps raw_input. New fields could be added upon request.
type PhoneNumber_CountryCodeSource int32

const (
	// The country_code is derived based on a phone number with a leading "+", e.g. the French
	// number "+33 1 42 68 53 00".
	PhoneNumber_FROM_NUMBER_WITH_PLUS_SIGN PhoneNumber_CountryCodeSource = 1
	// The country_code is derived based on a phone number with a leading IDD, e.g. the French
	// number "011 33 1 42 68 53 00", as it is dialled from US.
	PhoneNumber_FROM_NUMBER_WITH_IDD PhoneNumber_CountryCodeSource = 5
	// The country_code is derived based on a phone number without a leading "+", e.g. the French
	// number "33 1 42 68 53 00" when defaultCountry is supplied as France.
	PhoneNumber_FROM_NUMBER_WITHOUT_PLUS_SIGN PhoneNumber_CountryCodeSource = 10
	// The country_code is derived NOT based on the phone number itself, but from the defaultCountry
	// parameter provided in the parsing function by the clients. This happens mostly for numbers
	// written in the national format (without country code). For example, this would be set when
	// parsing the French number "01 42 68 53 00", when defaultCountry is supplied as France.
	PhoneNumber_FROM_DEFAULT_COUNTRY PhoneNumber_CountryCodeSource = 20
)

var PhoneNumber_CountryCodeSource_name = map[int32]string{
	1:  "FROM_NUMBER_WITH_PLUS_SIGN",
	5:  "FROM_NUMBER_WITH_IDD",
	10: "FROM_NUMBER_WITHOUT_PLUS_SIGN",
	20: "FROM_DEFAULT_COUNTRY",
}
var PhoneNumber_CountryCodeSource_value = map[string]int32{
	"FROM_NUMBER_WITH_PLUS_SIGN":    1,
	"FROM_NUMBER_WITH_IDD":          5,
	"FROM_NUMBER_WITHOUT_PLUS_SIGN": 10,
	"FROM_DEFAULT_COUNTRY":          20,
}

func (x PhoneNumber_CountryCodeSource) Enum() *PhoneNumber_CountryCodeSource {
	p := new(PhoneNumber_CountryCodeSource)
	*p = x
	return p
}
func (x PhoneNumber_CountryCodeSource) String() string {
	return proto.EnumName(PhoneNumber_CountryCodeSource_name, int32(x))
}
func (x PhoneNumber_CountryCodeSource) MarshalJSON() ([]byte, error) {
	return json.Marshal(x.String())
}
func (x *PhoneNumber_CountryCodeSource) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PhoneNumber_CountryCodeSource_value, data, "PhoneNumber_CountryCodeSource")
	if err != nil {
		return err
	}
	*x = PhoneNumber_CountryCodeSource(value)
	return nil
}

type PhoneNumber struct {
	// The country calling code for this number, as defined by the International Telecommunication Union
	// (ITU). Fox example, this would be 1 for NANPA countries, and 33 for France.
	CountryCode *int32 `protobuf:"varint,1,req,name=country_code" json:"country_code,omitempty"`
	// National (significant) Number is defined in International Telecommunication Union (ITU)
	// Recommendation E.164. It is a language/country-neutral representation of a phone number at a
	// country level. For countries which have the concept of Area Code, the National (significant)
	// Number contains the area code. It contains a maximum number of digits which equal to 15 - n,
	// where n is the number of digits of the country code. Take note that National (significant) Number
	// does not contain National(trunk) prefix. Obviously, as a uint64, it will never contain any
	// formatting (hypens, spaces, parentheses), nor any alphanumeric spellings.
	NationalNumber *uint64 `protobuf:"varint,2,req,name=national_number" json:"national_number,omitempty"`
	// Extension is not standardized in ITU recommendations, except for being defined as a series of
	// numbers with a maximum length of 40 digits. It is defined as a string here to accommodate for the
	// possible use of a leading zero in the extension (organizations have complete freedom to do so,
	// as there is no standard defined). However, only ASCII digits should be stored here.
	Extension *string `protobuf:"bytes,3,opt,name=extension" json:"extension,omitempty"`
	// In some countries, the national (significant) number starts with one or more "0"s without this
	// being a national prefix or trunk code of some kind. For example, the leading zero in the national
	// (significant) number of an Italian phone number indicates the number is a fixed-line number.
	// There have been plans to migrate fixed-line numbers to start with the digit two since December
	// 2000, but it has not happened yet. See http://en.wikipedia.org/wiki/%2B39 for more details.
	//
	// These fields can be safely ignored (there is no need to set them) for most countries. Some
	// limited number of countries behave like Italy - for these cases, if the leading zero(s) of a
	// number would be retained even when dialling internationally, set this flag to true, and also
	// set the number of leading zeros.
	//
	// Clients who use the parsing functionality of the i18n phone number libraries
	// will have these fields set if necessary automatically.
	ItalianLeadingZero   *bool  `protobuf:"varint,4,opt,name=italian_leading_zero" json:"italian_leading_zero,omitempty"`
	NumberOfLeadingZeros *int32 `protobuf:"varint,8,opt,name=number_of_leading_zeros,def=1" json:"number_of_leading_zeros,omitempty"`
	// This field is used to store the raw input string containing phone numbers before it was
	// canonicalized by the library. For example, it could be used to store alphanumerical numbers
	// such as "1-800-GOOG-411".
	RawInput *string `protobuf:"bytes,5,opt,name=raw_input" json:"raw_input,omitempty"`
	// The source from which the country_code is derived.
	CountryCodeSource *PhoneNumber_CountryCodeSource `protobuf:"varint,6,opt,name=country_code_source,enum=i18n.phonenumbers.PhoneNumber_CountryCodeSource" json:"country_code_source,omitempty"`
	// The carrier selection code that is preferred when calling this phone number domestically. This
	// also includes codes that need to be dialed in some countries when calling from landlines to
	// mobiles or vice versa. For example, in Columbia, a "3" needs to be dialed before the phone number
	// itself when calling from a mobile phone to a domestic landline phone and vice versa.
	//
	// Note this is the "preferred" code, which means other codes may work as well.
	PreferredDomesticCarrierCode *string `protobuf:"bytes,7,opt,name=preferred_domestic_carrier_code" json:"preferred_domestic_carrier_code,omitempty"`
	XXX_unrecognized             []byte  `json:"-"`
}

func (m *PhoneNumber) Reset()         { *m = PhoneNumber{} }
func (m *PhoneNumber) String() string { return proto.CompactTextString(m) }
func (*PhoneNumber) ProtoMessage()    {}

const Default_PhoneNumber_NumberOfLeadingZeros int32 = 1

func (m *PhoneNumber) GetCountryCode() int32 {
	if m != nil && m.CountryCode != nil {
		return *m.CountryCode
	}
	return 0
}

func (m *PhoneNumber) GetNationalNumber() uint64 {
	if m != nil && m.NationalNumber != nil {
		return *m.NationalNumber
	}
	return 0
}

func (m *PhoneNumber) GetExtension() string {
	if m != nil && m.Extension != nil {
		return *m.Extension
	}
	return ""
}

func (m *PhoneNumber) GetItalianLeadingZero() bool {
	if m != nil && m.ItalianLeadingZero != nil {
		return *m.ItalianLeadingZero
	}
	return false
}

func (m *PhoneNumber) GetNumberOfLeadingZeros() int32 {
	if m != nil && m.NumberOfLeadingZeros != nil {
		return *m.NumberOfLeadingZeros
	}
	return Default_PhoneNumber_NumberOfLeadingZeros
}

func (m *PhoneNumber) GetRawInput() string {
	if m != nil && m.RawInput != nil {
		return *m.RawInput
	}
	return ""
}

func (m *PhoneNumber) GetCountryCodeSource() PhoneNumber_CountryCodeSource {
	if m != nil && m.CountryCodeSource != nil {
		return *m.CountryCodeSource
	}
	return 0
}

func (m *PhoneNumber) GetPreferredDomesticCarrierCode() string {
	if m != nil && m.PreferredDomesticCarrierCode != nil {
		return *m.PreferredDomesticCarrierCode
	}
	return ""
}

func init() {
	proto.RegisterEnum("i18n.phonenumbers.PhoneNumber_CountryCodeSource", PhoneNumber_CountryCodeSource_name, PhoneNumber_CountryCodeSource_value)
}
